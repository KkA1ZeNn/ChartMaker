<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <title>Лаб.Работа 1</title>
   <style>
      .settingBar {
         width: 100%;
         height: 7vh;
         display: flex;
         align-items: center;
         justify-content: flex-start;
         margin-bottom: 10px;
      }

      #options {
         width: auto;
         height: 25px;
         margin-left: 20px;
         display: flex;
         align-items: center;
         justify-content: flex-start;
      }

      #descret {
         width: auto;
         height: 100%;
         align-items: center;
         justify-content: flex-start;
      }

      #descret div {
         height: 100%;
         width: 20px;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: space-around;
         border-right: 2px solid black;
         margin-right: 10px;
         padding-right: 10px;
      }

      #descret div h5 {
         margin: 0;
      }

      #methods {
         width: 130px;
      }

      #generationCount {
         width: 50px;
      }

      #generate {
         margin-left: 20px;
      }

      label {
         margin: 0px 10px 0px 20px;
      }

      #workspace {
         width: 100%;
         height: 90vh;
         display: flex;
         align-items: top;
         justify-content: flex-start;
      }

      #generatedValues {
         width: 6%;
         height: 100%;
         border: 2px solid black;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: space-between;
         margin-right: 20px;
      }

      #description {
         width: 100%;
         height: 12%;
         border-bottom: 2px solid black;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: space-between;
      }

      #description h4 {
         width: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
         height: 50%;
         margin: 0;
         border-bottom: 2px solid black;
         box-sizing: border-box;
      }

      #KX {
         height: 50%;
         width: 100%;
         display: flex;
         align-items: center;
         justify-content: space-around;
      }

      #KX h5 {
         margin: 0;
         width: 50%;
         height: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
      }

      #KX h5:first-child {
         border-right: 2px solid black;
      }

      #values {
         width: 100%;
         height: 88%;
         overflow-y: auto;
      }

      .valueRow {
         height: 7%;
         width: 100%;
         display: flex;
         align-items: center;
         justify-content: space-around;
         border-bottom: 2px solid gray;
         box-sizing: border-box;
      }

      .valueRow h5 {
         margin: 0;
         width: 50%;
         height: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
      }

      .valueRow h5:first-child {
         border-right: 2px solid gray;
      }

      #graphics {
         width: 80%;
         height: 100%;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: space-between;
      }

      .graphicsRow {
         width: 100%;
         height: 50%;
         display: flex;
         align-items: center;
         justify-content: space-between;
      }

      .graph {
         width: 50%;
         height: 100%;
      }

      #calculated {
         border: 2px solid black;
         min-height: 50%;
         height: auto;
         width: 14%;
         display: flex;
         align-items: top;
         justify-content: space-between;
      }

      .calculatedColumn {
         width: 50%;
         height: 100%;
         font-size: 13px;
         font-weight: bold;
      }

      .calculatedColumn:first-child {
         border-right: 2px solid black;
      }

      .calculatedRow {
         padding-left: 5px;
         width: 100%;
         min-height: 20%;
         height: auto;
         border-bottom: 2px solid black;
         display: flex;
         align-items: center;
         justify-content: flex-start;
         box-sizing: border-box;
         word-break: break-all;
      }

      .calculatedRow:last-child {
         border: none;
      }

      #values::-webkit-scrollbar {
         display: none;
      }

      .option {
         display: none;
         margin-right: 10px;
      }

      #manual_label {
         margin-left: 0px;
         margin-right: 10px;
      }

      #clear {
         margin-right: 10px;
      }

   </style>
</head>
<body>
   <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/percent.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/locales/de_DE.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/geodata/germanyLow.js"></script>
   <script src="https://cdn.amcharts.com/lib/5/fonts/notosans-sc.js"></script>

   <div class="settingBar">
      <button id = "clear">Clear</button>
      <input type="checkbox" id = "manual">
      <label for="manual" id = "manual_label">Ручной режим</label>
      <select id="methods" required>
         <option selected style="display: none;"></option>
         <option value="1.1 Бернулли">1.1 Бернулли</option>
         <option value="1.2 Биномиальное">1.2 Биномиальное</option>
         <option value="1.3 Пуассона">1.3 Пуассона</option>
         <option value="1.4 Дискретное">1.4 Дискретное</option>
      </select>
      <label for="generationCount">Кол-во генер.знач.</label>
      <input name="count of generations" id = "generationCount" value = "100">

      <div id = "options">
         <input name = "option1" class = "option" id = "q" placeholder = "Вероятность успеха Q =" type = "text">
         <input name = "option2" class = "option" id = "m" placeholder = "Число исходов M =" type = "text">
         <input name = "option3" class = "option" id = "alpha" placeholder = "Интенсивность λ =" type = "text">
         <div class = "option" id = "descret"></div>
      </div>
      <input name = "option4" class = "option" id = "manual_text" placeholder = "Вставьте выборку из Excel" type = "text">
      <input name = "option5" class = "option" id = "manual_descret" placeholder = "Вставьте параметры распр." type = "text">
      <button id = "generate">Генерация</button>
   </div>

   <div id = "workspace">
      <div id = "generatedValues">
         <div id = "description">
            <h4>Выборка</h4>
            <div id = "KX">
               <h5>K</h5>
               <h5>X</h5>
            </div>
         </div>
         <div id = "values"></div>
      </div>
      <div id = "graphics">
         <div class = "graphicsRow">
            <div class = "graph" id = "graph1"></div>
            <div class = "graph" id = "graph2"></div>
         </div>
         <div class = "graphicsRow">
            <div class = "graph" id = "graph3"></div>
            <div class = "graph" id = "graph4"></div>
         </div>
      </div>
      <div id = "calculated">
         <div class = "calculatedColumn">
            <div class="calculatedRow">
               Математическое ожидание (МО):
            </div>
            <div class="calculatedRow">
               Среднеквадратичное отклонения (СКО):
            </div>
            <div class="calculatedRow">
               Дисперсия:
            </div>
            <div class="calculatedRow">
               Ассиметрия:
            </div>
            <div class="calculatedRow">
               Эксцесс
            </div>
         </div>
         <div class="calculatedColumn" id = "secondColumn">

         </div>
      </div>
   </div>

   <script>
      // Переменные всяких элементов из HTML
      const generationMethod = document.querySelector('#methods');
      const generateButton = document.querySelector('#generate');
      const clearButton = document.querySelector('#clear');
      const generationCount = document.querySelector('#generationCount');
      const generatorOptionQ = document.querySelector('#q');
      const generatorOptionM = document.querySelector('#m');
      const generatorOptionAlpha = document.querySelector('#alpha');
      const generatorOptionDescret = document.querySelector('#descret');
      const generatorOptionManualCheckbox = document.querySelector('#manual');
      const generatorOptionManual = document.querySelector('#manual_text');
      const generatorOptionManualDescret = document.querySelector('#manual_descret');
      const valuesBar = document.querySelector('#values');
      const calculatedColumn = document.querySelector('#secondColumn');

      // Переменные для построения графиков: values -  массив со значениями Х из выборки, остальные два нужны для построения дискретного метода
      let values = [];
      let Xi = [];
      let Pi = [];

      // Переменные 4х графиков и массива в котором будут храниться значения всех чисел и их повторений
      let root; 
      let root2;
      let root3;
      let root4;
      let numbersCount;
      let manualFlag = false;

      generatorOptionManualCheckbox.addEventListener('change', () => {
         if (generatorOptionManualCheckbox.checked){
            generatorOptionManual.style.display = "block";
            generationCount.disabled = true;
            manualFlag = true;
            if (generationMethod.value === "1.4 Дискретное") {
               generatorOptionManualDescret.style.display = "block";
            }
         } else {
            generatorOptionManual.style.display = "none";
            generatorOptionManualDescret.style.display = "none";
            manualFlag = false;
            generationCount.disabled = false;
         }
      })

      // Обработчик кнопки генерации
      generateButton.addEventListener('click', () => {
         if (generationMethod.value !== "" && ( (!manualFlag && generationCount.value !== "") || (manualFlag && generatorOptionManual.value !== "") )) {
            generatorOptionDescret.style.display = "flex";
            valuesBar.innerHTML = ``;
            generatorOptionDescret.innerHTML = ``;
            calculatedColumn.innerHTML = ``;
            values = [];
            let descretTemp = [];
            let newValue;
            let q,m,lambda;
            Xi = [];
            Pi = [];

            switch (generationMethod.value) {
               case "1.1 Бернулли":
                  q = parseFloat(generatorOptionQ.value);
                  if (typeof q !== "number" || q < 0 || q > 1 || generatorOptionQ.value == "") {
                     alert ("Q должно быть числом от 0 до 1");
                     throw new Error ("Q должно быть числом от 0 до 1");
                  }

                  if (manualFlag) {
                     values = generatorOptionManual.value.split(" ").map((element) => {return parseInt(element)});
                  } else {
                     for (let i = 0; i < generationCount.value; i++) {
                        newValue = bernoulli(q);
                        values.push(newValue);
                     }
                  }
                  break;

               case "1.2 Биномиальное":
                  q = parseFloat(generatorOptionQ.value);
                  m = parseFloat(generatorOptionM.value);
                  if (typeof q !== "number" || q < 0 || q > 1 || generatorOptionQ.value == "") {
                     alert ("Q должно быть числом от 0 до 1");
                     throw new Error ("Q должно быть числом от 0 до 1");
                  }
                  if (typeof m !== "number" || m < 0 || generatorOptionM.value == "") {
                     alert ("M должно быть числом больше 0");
                     throw new Error ("M должно быть числом больше 0");
                  }

                  if (manualFlag) {
                     values = generatorOptionManual.value.split(" ").map((element) => {return parseInt(element)});
                  } else {
                     for (let i = 0; i < generationCount.value; i++) {
                        newValue = binomial(m, q);
                        values.push(newValue);
                     }
                  }
                  break;

               case "1.3 Пуассона":
                  lambda = parseFloat(generatorOptionAlpha.value);
                  if (typeof lambda !== "number" || lambda < 0 || generatorOptionAlpha.value == "") {
                     alert ("Lamda должно быть числом больше 0");
                     throw new Error ("Lamda должно быть числом больше 0");
                  }

                  if (manualFlag) {
                     values = generatorOptionManual.value.split(" ").map((element) => {return parseInt(element)});
                  } else {
                     for (let i = 0; i < generationCount.value; i++) {
                        newValue = poisson(lambda);
                        values.push(newValue);
                     }
                  }
                  break;

               case "1.4 Дискретное":
                  const valueRow = document.createElement('div');
                  valueRow.innerHTML = `
                     <h5>Xi</h5>
                     <h5>Pi</h5>
                  `;
                  generatorOptionDescret.appendChild(valueRow);

                  if (manualFlag) {
                     if (generatorOptionManualDescret.value == "") {
                        alert ("Поле параметров распределения не может быть пустым");
                        throw new Error ("Поле параметров распределения не может быть пустым");
                     }
                     values = generatorOptionManual.value.split(" ").map((element) => {return parseInt(element)});
                     descretTemp = generatorOptionManualDescret.value.split(" ");
                     for (let i = 0; i < descretTemp.length; ++i) {  
                        let tempArr = descretTemp[i].split("\t");
                        Xi.push( parseInt(tempArr[0]) );
                        Pi.push( parseFloat(tempArr[1].replace(',', '.')) );

                        const valueRow = document.createElement('div');
                        valueRow.innerHTML = `
                           <h5>${ Xi[i] }</h5>
                           <h5>${ Pi[i] }</h5>
                        `;
                        generatorOptionDescret.appendChild(valueRow);
                     }
                  } else {
                     for (let i = 0; i < 10; ++i) {
                        descretTemp.push( myRandom(1, 10) );
                     }

                     let sum = descretTemp.reduce(function(a, b){
                        return a + b;
                     }, 0);

                     for (let i = 0; i < 10; ++i) {                 
                        Xi.push( myRandom(1, 40) );
                        Pi.push( parseFloat((descretTemp[i] / sum ).toFixed(3)) );

                        const valueRow = document.createElement('div');
                        valueRow.innerHTML = `
                           <h5>${ Xi[i] }</h5>
                           <h5>${ Pi[i] }</h5>
                        `;
                        generatorOptionDescret.appendChild(valueRow);
                     }
                     for (let i = 0; i < generationCount.value; i++) {
                        newValue = discrete(Xi, Pi);
                        values.push ( newValue );
                     }
                  }
                  break;
            }
         
            for (let i = 0; i < values.length; i++) {
               const valueRow = document.createElement('div');
               valueRow.classList.add("valueRow");
               valueRow.innerHTML = `
                  <h5>${ i + 1 }</h5>
                  <h5>${ values[i] }</h5>
               `;
               valuesBar.appendChild(valueRow);
            }

            numbersCount = countOccurrences(values);
            graph1Creator();
            graph2Creator();
            graph3Creator();
            graph4Creator();
            calculateStatistics(values);
            
         } else {
            alert("Значения настроек не могут быть пустыми");
            throw new Error ("Значения настроек не могут быть пустыми");
         }
      })


      //----------------------------------------------------------------------------------Дальше будут функции разных методов генерации


      // Функция, которая возвращает биномиально распределенное случайное число
      // n - количество испытаний, q - вероятность успеха
      function binomial(n, q) {
         let k = 0;
         // Повторяем n раз
         for (let i = 0; i < n; i++) {
            // Генерируем случайное число от 0 до 1
            let r = Math.random();
            // Если число меньше или равно p, то считаем это успехом и увеличиваем счетчик
            if (r <= q) {
               k++;
            }
         }
         // Возвращаем счетчик успехов
         return k;
      }

      // Функция, которая возвращает биномиальный коэффициент
      // n - количество испытаний, k - количество успехов
      function binomialCoefficient(n, k) {
         // Возвращаем отношение факториалов n, k и n-k
         return factorial(n) / (factorial(k) * factorial(n - k));
      }

      // Функция, которая возвращает биномиальную вероятность
      // n - количество испытаний, p - вероятность успеха, k - количество успехов
      function binomialProbability(n, p, k) {
         // Возвращаем произведение биномиального коэффициента и степеней p и 1-p
         return binomialCoefficient(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
      }

      // Фунция генерации чисел для выборки методом Бернулли
      function bernoulli (q) {
         // Генерируем случайное число от 0 до 1
         let random = Math.random ();
         // Сравниваем его с q и возвращаем результат
         return random <= q ? 1 : 0;
      }

      // Функция, которая возвращает пуассоновски распределенное случайное число
      // lambda - интенсивность события
      function poisson(lambda) {
         // Инициализируем k и u
         let k = 0;
         let u = Math.random();
         // Инициализируем F(k) и F(k-1)
         let F = Math.exp(-lambda); // F(0)
         let F_prev = 0; // F(-1)
         // Пока не найдем подходящее k
         while (u > F) {
            // Увеличиваем k на 1
            k++;
            // Обновляем F(k-1) и F(k)
            F_prev = F;
            F = F + Math.exp(-lambda) * Math.pow(lambda, k) / factorial(k);
         }
         // Возвращаем k
         return k;
      }
      
      // Функция, которая возвращает Пуассоновскую вероятность
      // k - количество событий, lambda - интенсивность события, n - количество испытаний
      function poissonProbability(k, lambda) {
         // Возвращаем произведение степени lambda n, факториала k и экспоненты отрицательного lambda n
         return Math.pow(lambda, k) / factorial(k) * Math.exp(-lambda);
      }

      // Функция, которая возвращает дискретно распределенное случайное число
      // X - массив возможных значений, P - массив соответствующих вероятностей
      function discrete(X, P) {
         // Проверяем, что массивы X и P имеют одинаковую длину и не пустые
         if (X.length !== P.length || X.length === 0) {
            return null; // Возвращаем null в случае ошибки
         }
         // Суммируем все вероятности из P
         let sum = 0;
         for (let p of P) {
            sum += p;
         }
         // Генерируем случайное число от 0 до суммы вероятностей
         let random = Math.random() * sum;
         // Ищем интервал, в который попадает случайное число
         let index = 0; // Индекс элемента из X, который будет возвращен
         let acc = 0; // Накопленная сумма вероятностей
         for (let i = 0; i < P.length; i++) {
            acc += P[i]; // Добавляем вероятность текущего элемента
            if (random < acc) {
               // Если случайное число меньше накопленной суммы, то мы нашли интервал
               index = i; // Запоминаем индекс элемента
               break; // Прерываем цикл
            }
         }
         // Возвращаем элемент из X по найденному индексу
         return X[index];
      }


      //----------------------------------------------------------------------------------Дальше будут функции построения графиков
  

      // Построение 1го графика (левый верхний)
      function graph1Creator() {
         // Define data
         let data = [];
         let yAxis;
         let xAxis;
         let chart;

         if (root) {
            root.dispose();
         }
         root = am5.Root.new("graph1");
         root.setThemes([
            am5themes_Animated.new(root)
         ]);

         chart = root.container.children.push( 
            am5xy.XYChart.new(root, {
               panY: false,
               wheelY: "zoomX",
            }) 
         );

         // Формирование данных для построения графика
         for (let i = 0; i < values.length; ++i) {
            data.push({
               K: i + 1,
               X: values[i]
            });
         }

         // Create Y-axis
         yAxis = chart.yAxes.push(
            am5xy.ValueAxis.new(root, {
               strictMinMax: true,
               maxPrecision: 0,
               renderer: am5xy.AxisRendererY.new(root, {})
            })
         );

         // Create X-Axis
         xAxis = chart.xAxes.push(
            am5xy.ValueAxis.new(root, {
               min: 1,
               max: values.length,
               renderer: am5xy.AxisRendererX.new(root, {})
            })
         );

         var series = chart.series.push( 
            am5xy.LineSeries.new(root, { 
               name: "Series",
               xAxis: xAxis, 
               yAxis: yAxis, 
               valueYField: "X", 
               valueXField: "K",
               maskBullets: false
            }) 
         );
      
         series.bullets.push(function() {
            return am5.Bullet.new(root, {
               sprite: am5.Circle.new(root, {
                  radius: 5,
                  fill: series.get("fill")
               })
            });
         });
      
         series.strokes.template.set("strokeWidth", 2);
         series.set("fill", am5.color(0xff8C00));
         series.set("stroke", am5.color(0xFFD700));
         series.data.setAll(data);
      }
   
      // Построение 2го графика (правый верхний)
      function graph2Creator() {
         // Define data
         let data = [];
         let yAxis;
         let xAxis;
         let chart;

         if (root2) {
            root2.dispose();
         }
         root2 = am5.Root.new("graph2");
         root2.setThemes([
            am5themes_Animated.new(root2)
         ]);

         chart = root2.container.children.push( 
            am5xy.XYChart.new(root2, {
               panY: false,
               wheelY: "zoomX",
               layout: root.verticalLayout
            }) 
         );
         
         // Формирование данных для построения графика
         for (key in numbersCount) {
            data.push({
               "number": parseInt(key),
               "value": numbersCount[key]
            });
         }

         // Create Y-axis
         yAxis = chart.yAxes.push(
            am5xy.ValueAxis.new(root2, {
               extraMax: 0.1,
               maxPrecision: 0,
               logarithmic: true,
               renderer: am5xy.AxisRendererY.new(root2, {})
            })
         );

         xAxis = chart.xAxes.push(
            am5xy.CategoryAxis.new(root2, {
               categoryField: "number",
               renderer: am5xy.AxisRendererX.new(root2, {})
            })
         );

         xAxis.data.setAll(data);

         var series = chart.series.push( 
            am5xy.ColumnSeries.new(root2, { 
               name: "Series",
               xAxis: xAxis, 
               yAxis: yAxis, 
               valueYField: "value", 
               categoryXField: "number",
               tooltip: am5.Tooltip.new(root2, {
                  labelText: "'{categoryX}' = {valueY}"
               })
            }) 
         );

         series.columns.template.setAll({
            width: am5.percent(60)
         });
         
         chart.set("cursor", am5xy.XYCursor.new(root2, {}));

         let cursor = chart.get("cursor");
         cursor.lineY.setAll({
            visible: false
         });
         cursor.lineX.setAll({
            visible: false
         });

         series.data.setAll(data);
         series.set("fill", am5.color(0xff8C00));
         series.set("stroke", am5.color(0xff8C00));
      }

      // Построение 3го графика (левый нижний)
      function graph3Creator() {
         // Define data
         let data = [];
         let yAxis;
         let xAxis;
         let chart;
         let teorValue;
         let otnValue;

         if (root3) {
            root3.dispose();
         }
         root3 = am5.Root.new("graph3");
         root3.setThemes([
            am5themes_Animated.new(root3)
         ]);

         chart = root3.container.children.push( 
            am5xy.XYChart.new(root3, {
               panY: false,
               wheelY: "zoomX",
               layout: root.verticalLayout
            }) 
         );

         // Формирование данных для построения графика
         switch (generationMethod.value) {
            case "1.1 Бернулли":
               for (key in numbersCount) {
                  otnValue = numbersCount[key] / values.length;
                  if (parseInt(key) == 1) {
                     teorValue = parseFloat(generatorOptionQ.value);
                  } else {
                     teorValue = 1 - parseFloat(generatorOptionQ.value);
                  }
                  data.push({
                     "number": parseInt(key),
                     "otnValue": otnValue,
                     "teorValue": teorValue
                  });
               }
               break;

            case "1.2 Биномиальное":
               for (key in numbersCount) {
                  otnValue = numbersCount[key] / values.length;
                  teorValue = binomialProbability( parseFloat( generatorOptionM.value), parseFloat( generatorOptionQ.value), parseInt(key) );
                  data.push({
                     "number": parseInt(key),
                     "otnValue": otnValue,
                     "teorValue": teorValue
                  });
               }
               break;

            case "1.3 Пуассона":
               for (key in numbersCount) {
                  otnValue = numbersCount[key] / values.length;
                  teorValue = poissonProbability( parseInt(key), parseFloat(generatorOptionAlpha.value) );
                  data.push({
                     "number": parseInt(key),
                     "otnValue": otnValue,
                     "teorValue": teorValue
                  });
               }
               break;

            case "1.4 Дискретное":
               for (key in numbersCount) {
                  otnValue = numbersCount[key] / values.length;
                  let index = Xi.indexOf( parseInt(key) );
                  teorValue = Pi[index];
                  data.push({
                     "number": parseInt(key),
                     "otnValue": otnValue,
                     "teorValue": teorValue
                  });
               }
               break;
            }

         // Create Y-axis
         yAxis = chart.yAxes.push(
            am5xy.ValueAxis.new(root3, {
               strictMinMax: true,
               renderer: am5xy.AxisRendererY.new(root3, {})
            })
         );

         // Create X-axis
         xAxis = chart.xAxes.push(
            am5xy.CategoryAxis.new(root3, {
               minGridDistance: 1,
               renderer: am5xy.AxisRendererX.new(root3, {
                  cellStartLocation: 0.1,
                  cellEndLocation: 0.6
               }),
               categoryField: "number"
            })
         );

         xAxis.data.setAll(data);

         var series = chart.series.push( 
            am5xy.ColumnSeries.new(root3, { 
               name: "Series",
               xAxis: xAxis, 
               yAxis: yAxis, 
               valueYField: "otnValue", 
               categoryXField: "number",
               tooltip: am5.Tooltip.new(root3, {
                  labelText: "отн.для {categoryX}={valueY}"
               })
            }) 
         );

         var series2 = chart.series.push( 
            am5xy.ColumnSeries.new(root3, { 
               name: "Series",
               xAxis: xAxis, 
               yAxis: yAxis, 
               valueYField: "teorValue", 
               categoryXField: "number",
               tooltip: am5.Tooltip.new(root3, {
                  labelText: "теор.для {categoryX}={valueY}"
               })
            }) 
         );

         series.columns.template.setAll({
            width: am5.percent(90)
         });
         series2.columns.template.setAll({
            width: am5.percent(90)
         });
         
         chart.set("cursor", am5xy.XYCursor.new(root3, {}));

         let cursor = chart.get("cursor");
         cursor.lineY.setAll({
            visible: false
         });
         cursor.lineX.setAll({
            visible: false
         });

         series.data.setAll(data);
         series2.data.setAll(data);
         series2.set("fill", am5.color(0xff8C00));
         series2.set("stroke", am5.color(0xff8C00));
      }

      // Построение 4го графика (правый нижний)
      function graph4Creator() {
         // Define data
         let data = [];
         let yAxis;
         let xAxis;
         let chart;
         let otnValue;
         let lastValue = 0;

         if (root4) {
            root4.dispose();
         }
         root4 = am5.Root.new("graph4");
         root4.setThemes([
            am5themes_Animated.new(root4)
         ]);

         chart = root4.container.children.push( 
            am5xy.XYChart.new(root4, {
               panY: false,
               wheelY: "zoomX",
            }) 
         );

         // Формирование данных для построения графика
         for (key in numbersCount) {
            otnValue = numbersCount[key] / values.length + lastValue;
            lastValue = otnValue;
            data.push({
               "number": parseInt(key),
               "Fx": otnValue
            });
         }

         // Create Y-axis
         yAxis = chart.yAxes.push(
            am5xy.ValueAxis.new(root4, {
               strictMinMax: true,
               extraMax: 0.1,
               renderer: am5xy.AxisRendererY.new(root4, {})
            })
         );

         // Create X-Axis
         xAxis = chart.xAxes.push(
            am5xy.ValueAxis.new(root4, {
               strictMinMax: true,
               maxPrecision: 0,
               renderer: am5xy.AxisRendererX.new(root4, {})
            })
         );

         var series = chart.series.push( 
            am5xy.SmoothedXLineSeries.new(root4, { 
               name: "Series",
               xAxis: xAxis, 
               yAxis: yAxis, 
               valueYField: "Fx", 
               valueXField: "number",
               maskBullets: false,
               tooltip: am5.Tooltip.new(root4, {
                  labelText: "{valueY}"
               })
            }) 
         );
      
         series.bullets.push(function() {
            return am5.Bullet.new(root4, {
               sprite: am5.Circle.new(root4, {
                  radius: 5,
                  fill: series.get("fill")
               })
            });
         });
         
         series.get("tooltip").label.set("text", "{valueY}")
         chart.set("cursor", am5xy.XYCursor.new(root4, {
            behavior: "zoomXY",
            xAxis: xAxis
         }));
         yAxis.set("tooltip", am5.Tooltip.new(root4, {
            themeTags: ["axis"]
         }));

         series.strokes.template.set("strokeWidth", 2);
         series.data.setAll(data);
         series.set("fill", am5.color(0xff8C00));
         series.set("stroke", am5.color(0xFFD700));
      }


      //----------------------------------------------------------------------------------Дальше будут просто вспомогательные функции


      // Функция подсчета повторяющегося значения в массиве
      function countOccurrences(arr) {
         return arr.reduce((acc, curr) => {
            acc[curr] ? acc[curr]++ : (acc[curr] = 1);
            return acc;
         }, {});
      }

      // Функция очистки всех полей настроек и удаления графиков
      function clear() {
         generationMethod.selectedIndex = 0;
         generatorOptionQ.value = "";
         generatorOptionM.value = "";
         generatorOptionAlpha.value = "";
         generatorOptionManual.value = "";
         generatorOptionManualDescret.value = "";
         generatorOptionDescret.innerHTML = ``;
         generationCount.value = "100";
         if (root) {
            root.dispose();
            root2.dispose();
            root3.dispose();
            root4.dispose();
         }
      }

            // Функция, которая получает на вход массив и может посчитать мат.ожидание, среднеквадратичное отклонение, дисперсию, Ассиметрию и эксцесс
      function calculateStatistics(arr) {
         const n = arr.length;
         const mean = arr.reduce((acc, val) => acc + val, 0) / n;
         const variance = arr.reduce((acc, val) => acc + (val - mean) ** 2, 0) / n;
         const stdDev = Math.sqrt(variance);
         const skewness = arr.reduce((acc, val) => acc + ((val - mean) / stdDev) ** 3, 0) / n;
         const excess = arr.reduce((acc, val) => acc + ((val - mean) / stdDev) ** 4, 0) / n - 3;

         for (let i = 0; i < 5; i++) {
            const calculatedRow = document.createElement('div');
            calculatedRow.classList.add("calculatedRow");
            switch (i) {
               case 0:
                  calculatedRow.innerHTML = `
                     ${ mean.toFixed(2) }
                  `;
                  break;
               case 1:
                  calculatedRow.innerHTML = `
                     ${ stdDev.toFixed(4) }
                  `;
                  break;
               case 2:
                  calculatedRow.innerHTML = `
                     ${ variance.toFixed(4) }
                  `;
                  break;
               case 3:
                  calculatedRow.innerHTML = `
                     ${ skewness.toFixed(4) }
                  `;
                  break;
               case 4:
                  calculatedRow.innerHTML = `
                     ${ excess.toFixed(4) }
                  `;
                  break;
            }
            calculatedColumn.appendChild(calculatedRow);
         }
      }

      // Функция, которая возвращает случайное целое число от min до max включительно
      function myRandom(min, max) {
         return Math.floor(Math.random() * (max - min + 1) + min);
      }

      // Функция, которая возвращает факториал числа n
      function factorial(n) {
         // Если n равно 0 или 1, то возвращаем 1
         if (n === 0 || n === 1) {
            return 1;
         }
         // Иначе, возвращаем произведение n и факториала n-1
         else {
            return n * factorial(n - 1);
         }
      }

      // Обработчик событий для реагирования на выбор метода 
      generationMethod.addEventListener('change', () => {
         switch (generationMethod.value) {
            case "1.1 Бернулли":
               generatorOptionQ.style.display = "block";
               generatorOptionM.style.display = "none";
               generatorOptionAlpha.style.display = "none";
               generatorOptionDescret.style.display = "none";
               generatorOptionManualDescret.style.display = "none";
               break;

            case "1.2 Биномиальное":
               generatorOptionQ.style.display = "block";
               generatorOptionM.style.display = "block";
               generatorOptionAlpha.style.display = "none";
               generatorOptionDescret.style.display = "none";
               generatorOptionManualDescret.style.display = "none";
               break;

            case "1.3 Пуассона":
               generatorOptionAlpha.style.display = "block";
               generatorOptionQ.style.display = "none";
               generatorOptionM.style.display = "none";
               generatorOptionDescret.style.display = "none";
               generatorOptionManualDescret.style.display = "none";
               break;

            case "1.4 Дискретное":
               generatorOptionAlpha.style.display = "none";
               generatorOptionQ.style.display = "none";
               generatorOptionM.style.display = "none";
               generatorOptionDescret.style.display = "none";
               if (manualFlag) {
                  generatorOptionManualDescret.style.display = "block";
               } else {
                  generatorOptionManualDescret.style.display = "none";
               }
               break;

            default:
               generatorOptionQ.style.display = "none";
               generatorOptionM.style.display = "none";
               generatorOptionAlpha.style.display = "none";
               generatorOptionDescret.style.display = "none";
               generatorOptionManualDescret.style.display = "none";
               break;
         }
      });
   
      // Обработчик кнопки очистки
      clearButton.addEventListener('click', clear);
   </script>
</body>
</html>